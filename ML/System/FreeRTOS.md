# Introduction
Суперцикл. Проблемы:
* синхронизация / жёсткая времянка тасков
* переключение задач
* функция блокирует весь цикл
FreeRTOS:
1. Аппаратные прерывания - гарантированное время реакции на внешние события.
2. Подсистема планирования процессов на основе приоритетов.
3. Быстрое реагирование на события (вызов обработчика - десятки мкс, переключение задач - сотни мкс)
Преимущества:
1. Расширяемость - синхронизация модулей возлагается на ОС, снижение связанности модулей.
2. Модульность - инкапсуляция функционала.
3. Командная работа - разработка модулей более самостоятельна.
4. Упрощение тестирования - модульное тестирование.
5. Реиспользование кода - модульность + снижение зависимостей.
6. Планирование процессорного времени - ненужные задачи не вызываются.
7. Утилизация времени - задача idle запускается при простое. Можно использовать для фоновых задач или оценки ресурса ЦП.
8. Управление питанием - большее время в режиме пониженного потребления.
9. Отложенная обработка прерывания - обработчик можно минимизировать, перенеся обработку в задачу или демон.
# Installation
freertos.org
* Kernel > Developer Docs
# Architecture
Вся конфигурация - freertos_config.h

#research STM: UM1722 - user manual - Developing Applications on STM32Cube with RTOS
## Tasks
### Creation
* Создание - xTaskCreate() - возвращает pass или fail (недостаточно памяти в куче)
	* pxTaskCode - только для отладки, ОС никак не обрабатывается, обычно ориентируются на название функции pcName #check
	* configSTACK_DEPTH_TYPE - размер стека в словах
	* pv Parameters - параметр, передаваемый задаче
	* uxPriority - приоритет
	* pxCreatedTask - дускриптор задачи
* Из кучи при создании задачи выделяется стек и TCB
* Task Control Block - struct xTASK_STATUS в task.h
	* usStackHighWaterMark - минимальное место стека, оставшее в процессе выполения задачи #ToDo 
* Приоритет
	* Установка xTaskCreate() или vTaskPrioritySet()
	* От 0 (min) до (configMAX_PRIORITIES - 1)
	* Всегда должна быть задача для выполнения (Idle с приоритетом 0)
	* Если несколько Ready задач имеют одинаковый приоритет, то планировщик будет по очереди передавать им управление
* Документация на API ОС для управления тасками - в task.h #ToDo 
### Блокировка
* vTaskDelay - время блокировки в тиках
* Циклическая задача: vTaskDelayUntil - тиков от события, например от времени последней передачи управления этой задаче
* https://www.youtube.com/watch?v=cZ7qdBZCcow 32:00 #ToDo 
### Idle task
* FreeRTOSConfig.h > configUSE_IDLE_HOOK 1 - позволяет в любом месте объявить прототип idle task
* Применение - idle_count++; - подсчёт тактов простоя
### Алгоритм планирования
* Алгоритм планирования с фиксированным приоритетом - сам алгоритм не изменяет приоритет (но и не препятствует его изменению)
* Упреждающее планирование - при появлении более приоритетной задачи передаёт управление ей, останавливая текущую
* configUSE_PREEMPTION
* configUSE_TIME_SLICING - разделение времени между задачами с одинаковыми приоритетами. Если 0, то задача сама уступает процессор.

# Articles
Основа - timeliness - своевременность обработки данных.
## Tasks
* Любой таск - функция
	* прототип: void vTask( void *pvParametres );
	* своя точка входа, свой стек
	* выполняется в бесконечном цикле (обычно не должна выходить из него)
	* одно определение может использоваться для создания нескольких тасков
	* Тело таска не должно содержать явных return, а таск уничтожается вызовом API
### Скелет таска
```
void vTask( void *pvParametres) {
    /* Данный фрагмент кода будет вызван один раз, перед запуском таска.
       Каждый созданный таск будет иметь свою копию someVar.
       Кроме объявления переменных, сюда можно поместить некоторый инициализационный код.    
    */
    int someVar;

    // Так как каждый таск - это по сути бесконечный цикл, то именно здесь начинается тело таска.
    for( ;; ) {
        // Тело таска
    }
    
    // Так как при нормальном поведении мы не должны выходить из тела таска, то в случае если это все таки произошло, мы удаляем таск.
    // Функция vTaskDelete принимает в качестве аргумента хэндл таска, который стоит удалить.
    // Вызов внутри тела таска с параметром NULL,удаляет текущий таск
    
    vTaskDelete( NULL );
}
```
### Создание и добавление в планировщик
Для этого используется API функция со следующим прототипом
```
portBASE_TYPE xTaskCreate( pdTASK_CODE pvTaskCode,  
                           const signed portCHAR * const pcName,  
                           unsigned portSHORT usStackDepth,  
                           void *pvParameters,  
                           unsigned portBASE_TYPE uxPriority,  
                           xTaskHandle *pxCreatedTask  
                         );
```
# Resources

* https://www.freertos.org/Documentation/RTOS_book.html
* https://www.freertos.org/RTOS-Xilinx-Zynq.html
* Xilinx wiki https://xilinx-wiki.atlassian.net/wiki/spaces/A/pages/18842141/FreeRTOS